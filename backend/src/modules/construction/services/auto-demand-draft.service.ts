import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import { FlatPaymentPlan } from '../../payment-plans/entities/flat-payment-plan.entity';
import { FlatPaymentPlanService } from '../../payment-plans/services/flat-payment-plan.service';
import { DemandDraftTemplateService } from '../../payment-plans/services/demand-draft-template.service';
import { DemandDraft, DemandDraftStatus } from '../../demand-drafts/entities/demand-draft.entity';
import { PaymentSchedule, ScheduleStatus } from '../../payments/entities/payment-schedule.entity';
import { ConstructionFlatProgress } from '../entities/construction-flat-progress.entity';
import { ConstructionPhase } from '../entities/construction-tower-progress.entity';
import { MilestoneDetectionService, MilestoneMatch } from './milestone-detection.service';
import { Flat } from '../../flats/entities/flat.entity';
import { Customer } from '../../customers/entities/customer.entity';
import { Booking } from '../../bookings/entities/booking.entity';
import { Property } from '../../properties/entities/property.entity';
import { Tower } from '../../towers/entities/tower.entity';

/**
 * Auto Demand Draft Generation Service
 * 
 * Automatically generates demand drafts when construction milestones are reached.
 * Uses templates to create HTML demand letters with all relevant details.
 */
@Injectable()
export class AutoDemandDraftService {
  private readonly logger = new Logger(AutoDemandDraftService.name);

  constructor(
    @InjectRepository(DemandDraft)
    private readonly demandDraftRepository: Repository<DemandDraft>,
    @InjectRepository(PaymentSchedule)
    private readonly paymentScheduleRepository: Repository<PaymentSchedule>,
    @InjectRepository(ConstructionFlatProgress)
    private readonly progressRepository: Repository<ConstructionFlatProgress>,
    @InjectRepository(Flat)
    private readonly flatRepository: Repository<Flat>,
    @InjectRepository(Customer)
    private readonly customerRepository: Repository<Customer>,
    @InjectRepository(Booking)
    private readonly bookingRepository: Repository<Booking>,
    @InjectRepository(Property)
    private readonly propertyRepository: Repository<Property>,
    @InjectRepository(Tower)
    private readonly towerRepository: Repository<Tower>,
    private readonly milestoneDetectionService: MilestoneDetectionService,
    private readonly flatPaymentPlanService: FlatPaymentPlanService,
    private readonly templateService: DemandDraftTemplateService,
  ) {}

  /**
   * Scheduled job to auto-generate demand drafts
   * Runs every 2 hours
   * COMMENTED OUT FOR NOW - Enable when ready for automation
   */
  // @Cron(CronExpression.EVERY_2_HOURS)
  // async autoGenerateDemandDrafts(): Promise<void> {
  //   this.logger.log('Starting auto demand draft generation...');
  //   try {
  //     const matches = await this.milestoneDetectionService.detectMilestones();
  //     
  //     for (const match of matches) {
  //       try {
  //         await this.generateDemandDraft(match);
  //       } catch (error) {
  //         this.logger.error(`Failed to generate demand draft for flat ${match.flatPaymentPlan.flatId}:`, error);
  //       }
  //     }
  //
  //     this.logger.log(`Generated ${matches.length} demand draft(s)`);
  //   } catch (error) {
  //     this.logger.error('Error during auto demand draft generation:', error);
  //   }
  // }

  /**
   * Generate demand draft for a milestone match
   */
  async generateDemandDraft(match: MilestoneMatch, systemUserId?: string): Promise<DemandDraft> {
    const { flatPaymentPlan, milestoneSequence, constructionProgress, amount } = match;

    // Get template
    const template = await this.templateService.findFirstActive();
    if (!template) {
      throw new NotFoundException('No active demand draft template found');
    }

    // Load all required data
    const flat = await this.flatRepository.findOne({
      where: { id: flatPaymentPlan.flatId },
      relations: ['property', 'tower'],
    });
    if (!flat) {
      throw new NotFoundException('Flat not found');
    }

    const customer = await this.customerRepository.findOne({
      where: { id: flatPaymentPlan.customerId },
    });
    if (!customer) {
      throw new NotFoundException('Customer not found');
    }

    const booking = await this.bookingRepository.findOne({
      where: { id: flatPaymentPlan.bookingId },
    });

    const milestone = flatPaymentPlan.milestones.find(m => m.sequence === milestoneSequence);
    if (!milestone) {
      throw new NotFoundException('Milestone not found');
    }

    // Calculate due date (default: 30 days from now)
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 30);

    // Create payment schedule entry
    const paymentSchedule = this.paymentScheduleRepository.create({
      bookingId: flatPaymentPlan.bookingId,
      scheduleNumber: `${flatPaymentPlan.bookingId.substring(0, 8)}-${milestoneSequence}`,
      installmentNumber: milestoneSequence,
      totalInstallments: flatPaymentPlan.milestones.length,
      milestone: milestone.name,
      description: milestone.description,
      dueDate,
      amount,
      status: ScheduleStatus.PENDING,
      paidAmount: 0,
    });
    const savedSchedule = await this.paymentScheduleRepository.save(paymentSchedule);

    // Prepare template data
    const templateData = {
      customerName: customer.fullName,
      propertyName: flat.property?.name || 'N/A',
      towerName: flat.tower?.name || 'N/A',
      flatNumber: flat.flatNumber,
      milestoneName: milestone.name,
      milestoneDescription: milestone.description,
      amount: amount.toLocaleString('en-IN'),
      dueDate: dueDate.toLocaleDateString('en-IN', { 
        day: '2-digit', 
        month: 'long', 
        year: 'numeric' 
      }),
      bankName: 'State Bank of India',
      accountName: 'Eastern Estate Pvt Ltd',
      accountNumber: '1234567890',
      ifscCode: 'SBIN0001234',
      branch: 'Kolkata Main Branch',
      customerEmail: customer.email || '',
      customerPhone: customer.phoneNumber || '',
    };

    // Render template
    const { subject, htmlContent } = this.templateService.renderTemplate(template, templateData);

    // Create demand draft
    const demandDraft = this.demandDraftRepository.create({
      flatId: flatPaymentPlan.flatId,
      customerId: flatPaymentPlan.customerId,
      bookingId: flatPaymentPlan.bookingId,
      milestoneId: milestone.name,
      amount,
      status: DemandDraftStatus.DRAFT,
      content: htmlContent,
      metadata: {
        subject,
        templateData,
      },
      paymentScheduleId: savedSchedule.id,
      flatPaymentPlanId: flatPaymentPlan.id,
      constructionCheckpointId: constructionProgress.id,
      autoGenerated: true,
      requiresReview: true,
      templateId: template.id,
      templateData,
      generatedAt: new Date(),
      createdBy: systemUserId || null,
    });

    const savedDemandDraft = await this.demandDraftRepository.save(demandDraft);

    // Update flat payment plan milestone
    await this.flatPaymentPlanService.updateMilestone(
      flatPaymentPlan.id,
      milestoneSequence,
      {
        status: 'TRIGGERED',
        dueDate: dueDate.toISOString(),
        paymentScheduleId: savedSchedule.id,
        demandDraftId: savedDemandDraft.id,
        constructionCheckpointId: constructionProgress.id,
      },
      systemUserId || 'SYSTEM',
    );

    // Mark construction checkpoint as triggered
    constructionProgress.isPaymentMilestone = true;
    constructionProgress.milestoneTriggered = true;
    constructionProgress.milestoneTriggeredAt = new Date();
    constructionProgress.demandDraftId = savedDemandDraft.id;
    constructionProgress.paymentScheduleId = savedSchedule.id;
    await this.progressRepository.save(constructionProgress);

    this.logger.log(
      `Generated demand draft ${savedDemandDraft.id} for flat ${flat.flatNumber}, milestone: ${milestone.name}`
    );

    return savedDemandDraft;
  }

  /**
   * Manually trigger demand draft generation for a specific milestone
   */
  async manualGenerateDemandDraft(
    flatPaymentPlanId: string,
    milestoneSequence: number,
    userId: string,
  ): Promise<DemandDraft> {
    const paymentPlan = await this.flatPaymentPlanService.findOne(flatPaymentPlanId);
    
    const milestone = paymentPlan.milestones.find(m => m.sequence === milestoneSequence);
    if (!milestone) {
      throw new NotFoundException('Milestone not found');
    }

    if (milestone.status !== 'PENDING') {
      throw new Error(`Milestone is already ${milestone.status}`);
    }

    // For construction-linked milestones, verify construction progress
    if (milestone.constructionPhase) {
      const canTrigger = await this.milestoneDetectionService.canTriggerMilestone(
        flatPaymentPlanId,
        milestoneSequence,
      );

      if (!canTrigger) {
        throw new Error(
          `Construction progress has not reached required level for this milestone. ` +
          `Required: ${milestone.phasePercentage}% of ${milestone.constructionPhase}`
        );
      }
    }

    // Get construction progress (or create a dummy one for token payments)
    let constructionProgress: ConstructionFlatProgress | null = null;
    
    if (milestone.constructionPhase) {
      constructionProgress = await this.progressRepository.findOne({
        where: { 
          flatId: paymentPlan.flatId, 
          phase: milestone.constructionPhase as ConstructionPhase
        },
      });
      if (!constructionProgress) {
        throw new NotFoundException('Construction progress record not found');
      }
    } else {
      // For token/down payment, create a temporary progress record
      constructionProgress = await this.progressRepository.findOne({
        where: { flatId: paymentPlan.flatId },
      });
      if (!constructionProgress) {
        throw new NotFoundException('No construction progress found for this flat');
      }
    }

    const match: MilestoneMatch = {
      flatPaymentPlan: paymentPlan,
      milestoneSequence,
      constructionProgress,
      milestoneName: milestone.name,
      amount: milestone.amount,
    };

    return await this.generateDemandDraft(match, userId);
  }

  /**
   * Approve and mark demand draft as ready to send
   */
  async approveDemandDraft(demandDraftId: string, userId: string): Promise<DemandDraft> {
    const demandDraft = await this.demandDraftRepository.findOne({
      where: { id: demandDraftId },
    });

    if (!demandDraft) {
      throw new NotFoundException('Demand draft not found');
    }

    demandDraft.status = DemandDraftStatus.READY;
    demandDraft.requiresReview = false;
    demandDraft.reviewedBy = userId;
    demandDraft.reviewedAt = new Date();
    demandDraft.updatedBy = userId;

    return await this.demandDraftRepository.save(demandDraft);
  }

  /**
   * Send demand draft to customer
   */
  async sendDemandDraft(demandDraftId: string, userId: string): Promise<DemandDraft> {
    const demandDraft = await this.demandDraftRepository.findOne({
      where: { id: demandDraftId },
    });

    if (!demandDraft) {
      throw new NotFoundException('Demand draft not found');
    }

    if (demandDraft.status !== DemandDraftStatus.READY) {
      throw new Error('Demand draft must be in READY status to send');
    }

    // TODO: Implement actual email/notification sending logic here
    // For now, just mark as sent
    demandDraft.status = DemandDraftStatus.SENT;
    demandDraft.sentAt = new Date();
    demandDraft.updatedBy = userId;

    this.logger.log(`Demand draft ${demandDraftId} marked as sent`);

    return await this.demandDraftRepository.save(demandDraft);
  }
}
